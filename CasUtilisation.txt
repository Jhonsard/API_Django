# Guide de Création d'une API REST avec Django

**Date :** 27/01/2026 - 01/02/2026  
**Auteur :** Documentation du projet APIsProj  

**Note :** Les développeurs travaillent sur les APIs en backend. Les utilisateurs utilisent le frontend ou le client pour consommer les APIs.

---

## Introduction

Ce guide présente les étapes pour créer une API REST en utilisant Django et Django REST Framework (DRF). Il couvre la configuration de l'environnement, la création des modèles, des vues, des sérialiseurs, et l'utilisation des ViewSets pour simplifier le développement.

---

## Étape 1 : Création d'un Environnement Virtuel

- Commande : `python3 -m venv venv`
- Activation : `source venv/bin/activate`

## Étape 2 : Installation des Dépendances

- Créer un fichier `requirements.txt` dans l'environnement virtuel.
- Ajouter les packages nécessaires (ex. : Django, djangorestframework).
- Installation : `pip install -r requirements.txt`

## Étape 3 : Création du Projet Django

- Entrer dans le dossier `backend`.
- Commande : `django-admin startproject core .`

## Étape 4 : Création d'une Application Django

- Toujours dans `backend`.
- Commande : `django-admin startapp nom_de_l_application` (ex. : `api`)
- Conseil : Ouvrir deux terminaux ; un pour le backend, un pour tester le frontend.

## Étape 5 : Configuration des Applications Installées

- Ouvrir `core/settings.py`.
- Dans `INSTALLED_APPS`, ajouter le nom de l'application locale (ex. : `'api'`).

## Étape 6 : Création du Fichier URLs de l'Application

- Dans le dossier `api`, créer un fichier `urls.py`.

## Étape 7 : Implémentation du Fichier URLs

- Importer `path` de `django.urls`.
- Créer une liste vide `urlpatterns`.

```python
# api/urls.py
from django.urls import path

urlpatterns = [
    # À remplir plus tard
]
```

## Étape 8 : Configuration des URLs Principales

- Ouvrir `core/urls.py`.
- Importer `include` de `django.urls`.
- Ajouter dans `urlpatterns` :

```python
path('api/', include('api.urls'))
```

## Étape 9 : Implémentation des Données JSON dans les Vues

- Ouvrir `api/views.py`.
- Importer `JsonResponse` de `django.http`.
- Définir une fonction `home` :

```python
def home(request):
    return JsonResponse({"message": "Hello World"})
```

## Étape 10 : Liaison des URLs et Test

- Dans `api/urls.py`, importer `home` et ajouter :

```python
path('', home, name='home')
```

- Pour tester : Créer un fichier `test.py` dans `client`.
- Importer `requests`.
- Définir l'endpoint : `endpoint = "http://localhost:8000/api"`
- Démarrer le serveur : `python3 manage.py runserver`
- Tester avec `requests.get(endpoint)`

**Note :** Pour passer des paramètres GET, ajouter `?q=valeur` à l'URL. Récupérer avec `request.GET.get('q')`.

---

## Étape 11 : Création du Modèle de Données

- Ouvrir `api/models.py`.
- Créer une classe `Product` héritant de `models.Model` :

```python
class Product(models.Model):
    name = models.CharField(max_length=255)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
```

- Migrations : `python3 manage.py makemigrations` puis `python3 manage.py migrate`.

---

## Étape 12 : Gestion des Requêtes POST

- Créer un fichier `create_product.py` dans `client`.
- Importer `requests`.
- Définir les données et envoyer :

```python
data = {"name": "Produit", "price": 10.00, "description": "Desc"}
response = requests.post(endpoint, json=data)
```

- Dans `views.py`, gérer le POST :

```python
import json
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def home(request):
    if request.method == 'POST':
        data = json.loads(request.body.decode('utf-8'))
        product = Product.objects.create(**data)
        return JsonResponse({"id": product.id, "name": product.name})
    # Logique GET
```

**Note :** `@csrf_exempt` désactive la vérification CSRF pour les APIs publiques.

---

## Étape 13 : Intégration du Modèle dans les Vues

- Importer `Product` dans `views.py`.
- Pour GET : Retourner la liste des produits.
- Pour POST : Créer et retourner le produit.

---

## Étape 14 : Introduction à Django REST Framework (DRF)

- Ajouter `'rest_framework'` dans `INSTALLED_APPS` de `settings.py`.
- Créer un sous-dossier `api` dans `api/`, avec `api.py` et `serializers.py`.
- Dans `serializers.py` :

```python
from rest_framework import serializers
from api.models import Product

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'
```

- Dans `api.py` :

```python
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from .serializers import ProductSerializer
from api.models import Product

@api_view(['GET', 'POST'])
def product_api_view(request):
    if request.method == 'GET':
        products = Product.objects.all()
        serializer = ProductSerializer(products, many=True)
        return Response(serializer.data)
    # Logique POST
```

---

## Étape 15 : Ajout des Méthodes PUT et DELETE
- Utiliser `get_object_or_404` pour récupérer un objet.
- Ajouter `'PUT'`, `'DELETE'` dans `@api_view`.
- Exemple pour GET d'un élément :
  ```python
  if request.method == 'GET':
      if pk:
          product = get_object_or_404(Product, pk=pk)
          serializer = ProductSerializer(product)
          return Response(serializer.data)
  ```

---

## Étape 16 : Utilisation de Thunder Client pour les Tests
- Installer l'extension Thunder Client dans VS Code.
- Créer une nouvelle requête, sélectionner la méthode (GET, POST, etc.).
- Entrer l'endpoint et cliquer sur "Send".
- Avantage : Évite de créer des fichiers de test manuels.

---

## Étape 17 : Validation des Données
- **Au niveau de l'API :**
  ```python
  if request.method == 'POST':
      name = request.data.get('name')
      if name in ['donald', 'trump']:
          return Response({"error": "Nom non autorisé"})
  ```
- **Au niveau du Serializer :**
  ```python
  class ProductSerializer(serializers.ModelSerializer):
      def validate_name(self, value):
          if value.lower() in ['donald', 'trump']:
              raise serializers.ValidationError("Nom non autorisé")
          return value
  ```

---

## Étape 18 : Utilisation des ViewSets
- Créer un fichier `routers.py` ou intégrer dans `urls.py`.
- Exemple :
  ```python
  from rest_framework.routers import DefaultRouter
  from .api.api import ProductViewSet

  router = DefaultRouter()
  router.register(r'products', ProductViewSet)
  urlpatterns = router.urls
  ```
- Dans `api.py` :
  ```python
  from rest_framework.viewsets import ModelViewSet

  class ProductViewSet(ModelViewSet):
      queryset = Product.objects.all()
      serializer_class = ProductSerializer
  ```
  Lui créer un fichier dit routers.py ou nous importons
  from django.urls import path
  from .viewset import ProductViewSet
  from rest_framework.routers import DefaultRouter, SimpleRouter

  le routeurs par defaut pour les operations CRUD, les SimpleRouter pour Les CRUD particuliere
  Utilisation du routeurs par defaut :
  router = DefaultRouter()
  router.register(r'meilleurs/products', ProductViewSet, basename='product')

  urlpatterns = router.urls

  Puis allons et placons le lien du fichier dans le urls.py de notre api

  Son avantage des viewsets est que à partir de trois lignes seulement dans son api, (viewset.py) nous finissons tout d'un coup.
  les trois lignes qui lui permettent qu'il soit générique, sont la:
  class ProductViewSet(ModelViewSet):
    serializer_class = ProductSerializer1
    queryset = Product.objects.all()

Pour vérifier dans le navigateur, taper : http://127.0.0.1:8000/api/meilleurs/products/
qui va nous envoyer un formulaire HTML

Étape 19 : Configuration personnalisée d'un formulaire d'entrée des données
           aller dans settings.py du package core

           au-dessus de la liste middleware, déclarons:
           REST_FRAMEWORK = {
        'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser', # J'accepte des données au format JSON
        'rest_framework.parsers.FormParser', # J'accepte des données au format form-data
        'rest_framework.renderers.BrowsableAPIRenderer',
        ]
}

          Après avoir importé action depuis la bibliothèque rest_framework.decorators,
          nous implémentons le code suivant:
            # route pour les produits avec un prix sup a 500
            @action(detail=False, methods=['GET'], url_path="expensive-product", url_name="expensive_product")
            def expensive_product(self, request, *args, **kwargs):
                products = Product.objects.filter(price__gte=500)
                context={'request': request}
                serializer = ProductSerializer1(products,many=True, context=context)
                return Response(serializer.data, status=status.HTTP_200_OK)

            @action(detail=False, methods=['GET'], url_path="cheap-product", url_name="cheap_product")
            def cheap_product(self, request, *args, **kwargs):
                products = Product.objects.filter(price__lte=12)
                context={'request': request}
                serializer = ProductSerializer1(products,many=True, context=context)
                return Response(serializer.data, status=status.HTTP_200_OK)

          le premier permet d'afficher les prix supérieurs ou égaux à 500 euros
          l'autre pour afficher celles inférieures à 12.

          ils seront appelés de cette manière dans le navigateur:

          le 1 : http://localhost:8000/api/meilleurs/products/expensive-product/
          le 2 : http://localhost:8000/api/meilleurs/products/cheap-product/

---

**Conseils Généraux :**
- Toujours activer l'environnement virtuel.
- Tester régulièrement avec le serveur en cours.
- Utiliser DRF pour simplifier la sérialisation et la validation.
- Éviter d'ajouter des champs dans le serializer qui n'existent pas dans le modèle, sauf surcharge de `create`.

Cette documentation couvre les bases de la création d'une API REST avec Django et DRF.
